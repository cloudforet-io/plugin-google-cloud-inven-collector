---
alwaysApply: true
---
# SpaceONE Google Cloud Collector: 코딩 및 프로젝트 규칙

이 문서는 SpaceONE Google Cloud Inventory Collector 플러그인 프로젝트의 일관성 있는 코드 스타일과 품질 유지를 위한 규칙을 정의합니다.

## 목차
1.  [이름 규칙 (Naming Conventions)](#1-이름-규칙-naming-conventions)
2.  [데이터 타입 및 연산 규칙 (Data Type & Operation Rules)](#2-데이터-타입-및-연산-규칙-data-type--operation-rules)
3.  [코드 포맷팅 및 린팅 (Code Formatting & Linting)](#3-코드-포맷팅-및-린팅-code-formatting--linting)
4.  [Import 규칙 (Import Rules)](#4-import-규칙-import-rules)
5.  [주석 및 문서화 (Comments & Documentation)](#5-주석-및-문서화-comments--documentation)
6.  [에러 처리 (Error Handling)](#6-에러-처리-error-handling)
7.  [테스트 (Testing)](#7-테스트-testing)
8.  [코드 품질 보증 (Code Quality Assurance)](#8-코드-품질-보증-code-quality-assurance)
9.  [규칙 자동 검증](#9-규칙-자동-검증)

---

## 1. 이름 규칙 (Naming Conventions)

### 1.1. 공통 규칙
- **한국어 사용 금지**: 변수, 함수, 클래스 등 코드의 모든 식별자에는 한국어를 사용하지 않습니다.
- **Todo 주석**: `# TODO: ` 형식으로 작성하여 향후 처리할 작업을 명시합니다.

### 1.2. 디렉토리 및 파일
- **`snake_case` 사용**: `http_file_connector`, `cost_manager.py`
- **단일 책임 원칙**: 모듈은 기능별로 명확하게 분리하고, 파일 이름에 그 기능이 드러나도록 작성합니다.
- **테스트 파일**: `test_` 접두사를 사용합니다. (예: `test_cost_manager.py`)

### 1.3. 변수 및 상수
- **변수**: `snake_case`를 사용합니다. (예: `user_name`, `cost_data`)
- **상수**: `UPPER_SNAKE_CASE`를 사용합니다. (예: `MAX_RETRY_COUNT`)

### 1.4. 함수 및 메서드
- **`snake_case` 사용**: `get_cost_data`, `validate_parameters`
- **내부 사용 함수/메서드**: 클래스/모듈 내부에서만 사용하는 경우 `_` (protected) 또는 `__` (private)로 시작합니다.
- **동사 중심 명명**:
  - **`get` / `list`**: 데이터를 조회할 때 사용합니다.
  - **`create`**: DB 저장이나 영구적인 리소스 생성을 목적으로 객체를 만들 때 사용합니다.
  - **`make`**: 다른 데이터를 조합하여 새로운 데이터(dict, list, query 등)를 메모리상에서 생성할 때 사용합니다.
  - **`generate`**: Key, Token 등 외부에 의존하지 않고 독립적으로 생성되는 값을 만들 때 사용합니다.

### 1.5. 클래스
- **`PascalCase` (CapWords) 사용**: `CostManager`, `HttpFileConnector`
- **에러 클래스**: `PascalCase`를 따르며, `Error` 접두사를 붙이는 것을 권장합니다. (예: `ErrorInvalidParameter`)

---

## 2. 데이터 타입 및 연산 규칙 (Data Type & Operation Rules)

### 2.1. 비용 계산 시 `Decimal` 타입 사용

모든 비용(cost) 및 환율(exchange rate) 등 정확한 소수점 연산이 필요한 모든 데이터 처리에는 부동소수점(`float`) 타입으로 인한 오차를 원천적으로 방지하기 위해 `Decimal` 타입을 **반드시** 사용해야 합니다.

- **`Decimal` 생성**: `Decimal` 객체를 생성할 때는 `Decimal(0.1)`과 같이 `float`를 직접 사용하는 대신, `Decimal("0.1")`처럼 **문자열(string)을 인자로 전달**하여 정확한 값을 보장해야 합니다.
- **타입 일관성**: `Decimal` 타입은 `Decimal` 타입과 연산하는 것을 원칙으로 합니다. `float` 또는 `int`와의 혼합 연산을 피해야 합니다.

#### 예시:
```python
from decimal import Decimal

# 잘못된 사용 예 (부동소수점 오차 발생)
cost_float = 0.1 + 0.2
# 결과: 0.30000000000000004

# 잘못된 사용 예 (float에서 변환 시 오차 발생)
cost_decimal_from_float = Decimal(0.1) + Decimal(0.2)
# 결과: Decimal('0.3000000000000000166533453694')

# 올바른 사용 예 (문자열로 Decimal 생성)
cost_decimal_from_string = Decimal("0.1") + Decimal("0.2")
# 결과: Decimal('0.3')
```

---

## 3. 코드 포맷팅 및 린팅 (Code Formatting & Linting)

### 3.1. 주요 도구: Ruff
- **Ruff**: Rust 기반의 통합 Python 도구로, 린팅, 포맷팅, 임포트 정렬 등을 모두 처리합니다.
- **표준화**: 프로젝트의 모든 코드 스타일은 `Ruff`를 통해 관리됩니다.
- **설정**: 모든 규칙은 `pyproject.toml` 파일에서 관리합니다.
- **임포트 정렬**: `Ruff`가 임포트 정렬(`I` 규칙)을 담당합니다. `pyproject.toml` 내의 `[tool.isort]` 설정은 과거 호환성 또는 참조용으로 유지될 수 있으나, 실제 적용은 `Ruff`를 통해 이루어집니다.

### 3.2. 프로젝트 설정 (`pyproject.toml`)
```toml
[project]
name = "plugin-google-cloud-inventory-collector"
version = "1.0.0"
description = "Google Cloud inventory collector plugin for SpaceONE"
authors = [
    {name = "SpaceONE Admin", email = "admin@spaceone.dev"}
]
license = {text = "Apache License 2.0"}
readme = "README.md"
requires-python = ">=3.8"
dependencies = [
    "spaceone-core",
    "spaceone-inventory",
    "schematics",
    "requests",
    "google-cloud-compute",
    "google-cloud-storage",
    "google-auth",
    "decimal"
]

[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[tool.ruff]
line-length = 88
target-version = "py38"

[tool.ruff.lint]
select = ["E", "F", "I", "N", "W", "B", "C4", "UP"]
ignore = ["E501"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"

[tool.isort]
profile = "black"
multi_line_output = 3
include_trailing_comma = true
force_grid_wrap = 0
use_parentheses = true
ensure_newline_before_comments = true
line_length = 88

[tool.pytest.ini_options]
norecursedirs = "test/disabled"
```

---

## 4. Import 규칙 (Import Rules)

### 4.1. 기본 원칙
- **계층 분리**: 같은 계층(예: service, manager, model)의 패키지를 서로 임포트하지 않습니다.
- **순환 참조 방지**: `Service` → `Manager` → `Connector` 순서의 의존성을 가지므로, 하위 계층에서 상위 계층을 직접 Import하지 않습니다.
- **임포트 최적화**: 사용하지 않는 임포트를 제거합니다.
- **직접 임포트**: `__init__.py`에서 임포트하는 대신 필요한 곳에서 직접 임포트하는 것을 선호합니다.

### 4.2. 개발 환경 및 의존성 관리
- **`spaceone` 패키지 Mocking**: 로컬에서 `spaceone` 관련 패키지 Import 오류 발생 시, 테스트나 개발에 필요한 부분만 Mock 객체로 처리하여 호환성을 유지합니다.

### 4.3. 와일드카드 Import 금지
- **`from ... import *` 사용 금지**: 와일드카드 임포트는 네임스페이스를 오염시키고 코드 가독성을 해치므로 절대 사용하지 않습니다.

---

## 5. 주석 및 문서화 (Comments & Documentation)

### 5.1. Docstrings (Google 스타일)
- 모든 공개 함수, 메서드, 클래스에는 Google 스타일 Docstring을 작성하여 `Args`, `Returns`, `Raises`를 명확히 합니다.
```python
def calculate_cost(usage_data: dict, rate: float = 0.1) -> float:
    """비용을 계산합니다.

    Args:
        usage_data: 사용량 데이터 딕셔너리.
        rate: 요금률 (기본값: 0.1).

    Returns:
        계산된 총 비용.

    Raises:
        ValueError: usage_data가 비어있을 경우.
    """
    if not usage_data:
        raise ValueError("Usage data cannot be empty.")
    # ...
```

### 5.2. 코드 내 주석
- **한국어 사용 원칙**: 코드의 의도를 설명하는 모든 주석(Docstring, 인라인 주석 등)은 이해를 돕기 위해 한국어로 작성하는 것을 원칙으로 합니다.
- 복잡한 로직이나 특정 결정의 배경을 설명해야 할 때만 간결한 주석을 추가합니다.
- API 함수는 타입 힌트를 필수로 포함해야 합니다.

### 5.3. 프로젝트 문서
- **`README.md`**: 각 디렉토리의 목적과 주요 기능을 설명합니다. (국문 작성)

---

## 6. 에러 처리 (Error Handling)

### 6.1. 예외 처리
- **구체적인 예외 명시**: `except Exception:` 보다 `except ValueError:` 와 같이 구체적인 예외를 잡습니다.
- **사용자에게 명확한 메시지 제공**: 에러 메시지는 문제 해결에 도움이 되도록 명확하고 간결하게 작성합니다.
- **불필요한 변수 제거**: `except` 블록에서 예외 객체를 사용하지 않는다면 변수를 선언하지 않습니다.

### 6.2. 예외 다시 발생 (Re-raising)
- **`raise from`**: 원래의 예외(cause)를 포함하여 디버깅을 용이하게 합니다.

---

## 7. 테스트 (Testing)

- **테스트 작성**: 모든 새로운 기능과 버그 수정에는 테스트 코드를 함께 작성합니다.
- **독립성**: 테스트는 서로 의존하지 않고 독립적으로 실행 가능해야 합니다.
- **구조 (Given-When-Then)**: 테스트의 의도를 명확히 하기 위해 준비(Given), 실행(When), 검증(Then) 구조를 따릅니다.
- **Mock 활용**: 외부 서비스나 의존성은 `unittest.mock`을 사용하여 격리합니다.
- **gRPC API 테스트**: `grpcurl`을 이용한 직접적인 API 테스트는 `SpaceONE` 환경 구성의 복잡성으로 인해 권장되지 않습니다. 대신, 핵심 로직이 담긴 `Manager`나 `Connector`를 직접 임포트하여 단위 테스트나 통합 테스트를 작성합니다.

---

## 8. 코드 품질 보증 (Code Quality Assurance)

모든 소스 코드 추가 및 수정 시, 아래의 절차를 반드시 수행하여 코드의 안정성과 품질을 보장합니다.

### 8.1. 개발 원칙
- **테스트 주도 개발 (TDD)**: 기능 구현 전, 실패하는 테스트 케이스를 먼저 작성하고 이를 통과시키는 코드를 개발하는 것을 원칙으로 합니다.
- **코드 커버리지**: 모든 코드 변경 사항은 충분한 테스트 코드로 뒷받침되어야 합니다. `pytest --cov`를 통해 커버리지를 측정하고, 핵심 로직은 높은 커버리지를 유지해야 합니다.

### 8.2. 필수 검증 절차
소스 코드 변경 후에는 반드시 다음 절차를 순서대로 진행하여 문제를 해결해야 합니다.

1.  **린터 및 포맷팅 검사**:
    - `Ruff`를 사용하여 코드 스타일과 포맷을 일관되게 유지합니다.
    - CI 환경에서는 `--check` 플래그를 사용하여 수정 없이 문제만 확인하고, 로컬에서는 자동 수정을 적용합니다.
      ```bash
      # 가상환경 활성화
      source venv/bin/activate
      
      # (CI) 린트 및 포맷 검사
      ruff check src/
      ruff format src/ --check

      # (Local) 린트 자동 수정 및 포맷팅 적용
      ruff check src/ --fix
      ruff format src/
      ```
    - "All checks passed!" 메시지를 확인해야 합니다.

2.  **단위 및 통합 테스트 및 커버리지 측정**:
    - `pytest`를 실행하여 모든 테스트가 성공하는지 확인하고, 코드 커버리지를 측정합니다.
      ```bash
      # 테스트 실행 및 커버리지 측정 (결과는 터미널에 출력)
      pytest --cov=src

      # 테스트 실행 및 커버리지 리포트(html) 생성
      pytest --cov=src --cov-report=html
      ```
    - 커버리지 리포트는 `htmlcov/index.html` 파일을 통해 확인할 수 있습니다.
    - 새로운 기능이나 로직 변경 시에는 반드시 관련 테스트 코드를 추가하거나 수정하여 높은 커버리지를 유지해야 합니다.

    - **테스트 결과 처리 원칙**:
      - **`INTERNAL ERROR` (내부 오류) 해결**: 테스트 실행 중 `INTERNAL ERROR`가 발생하는 것은 **절대 허용되지 않습니다.** 이는 테스트 케이스의 실패(`FAILED`)보다 더 심각한, 테스트 코드 자체의 구조적 결함(예: 잘못된 import, 구문 오류)을 의미합니다. `INTERNAL ERROR`가 발생한 경우, 다른 모든 작업을 중단하고 **최우선으로 해결해야 합니다.**
      - **`FAILED` (실패) 테스트 해결**: 모든 테스트 케이스는 **반드시 `PASSED` 되어야 합니다.** `FAILED` 상태의 테스트가 하나라도 존재하면, 이는 코드 변경으로 인해 기능이 손상되었거나(회귀), 요구사항을 만족하지 못함을 의미합니다. 코드 변경을 커밋하거나 Pull Request를 생성하기 전에 모든 테스트가 `PASSED` 상태임을 반드시 확인해야 합니다.

3.  **정적 분석 및 취약점 점검**:
    - (도입 시) `bandit`과 같은 도구를 사용하여 코드의 잠재적 보안 취약점을 점검합니다.
    - CI 단계에서 자동화된 검사를 통해 문제를 조기에 식별합니다.

4.  **성능 테스트**:
    - 데이터 처리 로직 등 성능에 영향을 줄 수 있는 코드를 수정한 경우, 성능 테스트를 수행합니다.
    - 대용량 샘플 데이터를 이용하여 실행 시간과 메모리 사용량을 측정하고, 성능 저하 여부를 확인합니다.

### 8.3. 자동화된 검증
- **IDE 연동**: 개발 환경(IDE/에디터)에서 실시간 린트 및 타입 체크 기능을 활성화합니다.
- **Git Hooks**: 커밋(commit) 전 Git Hook을 설정하여 린트 및 테스트를 자동으로 실행하도록 권장합니다.
- **CI/CD 파이프라인**: PULL REQUEST 생성 시, CI 파이프라인에서 위 모든 검증 절차(린트, 테스트, 빌드, 취약점 점검)가 자동으로 수행되어야 합니다.

---

## 9. 규칙 자동 검증

프로젝트의 주요 코딩 규칙은 `Ruff`를 통해 자동으로 검증됩니다. `grep`과 같은 수동 스크립트 대신 `ruff check src/` 명령을 실행하여 다음 규칙들이 준수되는지 확인합니다.

- **이름 규칙 (Naming Conventions)**:
  - `N801`: 클래스명은 `PascalCase` (CapWords)여야 합니다.
  - `N802`: 함수 및 메서드명은 `snake_case`여야 합니다.
  - `N803`: 인수 이름은 `snake_case`여야 합니다.
  - `N806`: 변수 이름은 `snake_case`여야 합니다.

- **Import 규칙 (Import Rules)**:
  - `I001`: 임포트가 정렬되지 않았습니다 (`ruff check --fix`로 자동 해결).
  - `F401`: 사용하지 않는 임포트가 있습니다 (`ruff check --fix`로 자동 해결).

- **에러 처리 (Error Handling)**:
  - `B014`: `except` 블록에서 사용하지 않는 예외 변수(예: `as e`)가 있습니다.
  - `B904`: `raise` 문에서 `from` 없이 예외를 다시 발생시킵니다. (명시적 예외 체이닝 권장)

- **기타 주요 규칙**:
  - `E501`: 라인 길이가 `line-length` 설정을 초과합니다. (`ruff format`으로 자동 해결)
  - `F841`: 할당되었지만 사용되지 않은 지역 변수가 있습니다.

이 규칙들은 `pyproject.toml`의 `[tool.ruff.lint].select`에 포함된 `N`, `I`, `B`, `F` 등에 의해 활성화됩니다. 전체 규칙 목록과 설명은 [Ruff Rules 문서](https://docs.astral.sh/ruff/rules/)를 참고하세요.
