---
alwaysApply: true
---
# SpaceONE Google Cloud Collector: 코딩 및 프로젝트 규칙

이 문서는 SpaceONE Google Cloud Inventory Collector 플러그인 프로젝트의 일관성 있는 코드 스타일과 품질 유지를 위한 규칙을 정의합니다.

## 목차
1.  [이름 규칙 (Naming Conventions)](#1-이름-규칙-naming-conventions)
2.  [코딩 스타일 및 포맷팅 (Code Style & Formatting)](#2-코딩-스타일-및-포맷팅-code-style--formatting)
3.  [복잡도 관리 (Complexity Management)](#3-복잡도-관리-complexity-management)
4.  [데이터 타입 및 연산 규칙 (Data Type & Operation Rules)](#4-데이터-타입-및-연산-규칙-data-type--operation-rules)
5.  [Import 규칙 (Import Rules)](#5-import-규칙-import-rules)
6.  [주석 및 문서화 (Comments & Documentation)](#6-주석-및-문서화-comments--documentation)
7.  [에러 처리 (Error Handling)](#7-에러-처리-error-handling)
8.  [타입 안전성 (Type Safety)](#8-타입-안전성-type-safety)
9.  [의존성 관리 (Dependency Management)](#9-의존성-관리-dependency-management)
10. [테스트 (Testing)](#10-테스트-testing)
11. [코드 품질 보증 (Code Quality Assurance)](#11-코드-품질-보증-code-quality-assurance)
12. [규칙 자동 검증](#12-규칙-자동-검증)
13. [프로젝트 특화 규칙](#13-프로젝트-특화-규칙)

---

## 1. 이름 규칙 (Naming Conventions)

### 1.1. 공통 규칙
- **한국어 사용 금지**: 변수, 함수, 클래스 등 코드의 모든 식별자에는 한국어를 사용하지 않습니다.
- **Todo 주석**: `# TODO: ` 형식으로 작성하여 향후 처리할 작업을 명시합니다.

### 1.2. 디렉토리 및 파일
- **`snake_case` 사용**: `http_file_connector`, `cost_manager.py`
- **단일 책임 원칙**: 모듈은 기능별로 명확하게 분리하고, 파일 이름에 그 기능이 드러나도록 작성합니다.
- **테스트 파일**: `test_` 접두사를 사용합니다. (예: `test_cost_manager.py`)

### 1.3. 변수 및 상수
- **변수**: `snake_case`를 사용합니다. (예: `user_name`, `cost_data`)
- **상수**: `UPPER_SNAKE_CASE`를 사용합니다. (예: `MAX_RETRY_COUNT`)

### 1.4. 함수 및 메서드
- **`snake_case` 사용**: `get_cost_data`, `validate_parameters`
- **내부 사용 함수/메서드**: 클래스/모듈 내부에서만 사용하는 경우 `_` (protected) 또는 `__` (private)로 시작합니다.
- **동사 중심 명명**:
  - **`get` / `list`**: 데이터를 조회할 때 사용합니다.
  - **`create`**: DB 저장이나 영구적인 리소스 생성을 목적으로 객체를 만들 때 사용합니다.
  - **`make`**: 다른 데이터를 조합하여 새로운 데이터(dict, list, query 등)를 메모리상에서 생성할 때 사용합니다.
  - **`generate`**: Key, Token 등 외부에 의존하지 않고 독립적으로 생성되는 값을 만들 때 사용합니다.

### 1.5. 클래스
- **`PascalCase` (CapWords) 사용**: `CostManager`, `HttpFileConnector`
- **에러 클래스**: `PascalCase`를 따르며, `Error` 접두사를 붙이는 것을 권장합니다. (예: `ErrorInvalidParameter`)

---

## 2. 코딩 스타일 및 포맷팅 (Code Style & Formatting)

### 2.1. 기본 스타일 규칙 (PEP8 기반)

#### 2.1.1. 들여쓰기
- **4 spaces 사용**: 탭(tab) 문자 금지, 일관된 4칸 공백 사용
- **중첩 수준**: 가독성을 위해 3단계를 초과하지 않도록 함수/메서드 분리 권장

#### 2.1.2. 줄 길이
- **최대 줄 길이**: 88자 (Ruff 기본값, Black 호환)
- **PEP8 79자 vs Ruff 88자**: 현대적 개발 환경과 가독성을 고려하여 88자 채택
- **긴 줄 처리**: 논리적 단위로 줄바꿈, 연산자 앞에서 줄바꿈 권장

#### 2.1.3. 공백 규칙
- **함수/클래스 간격**: 
  - 최상위 함수와 클래스 정의는 2줄 공백으로 구분
  - 클래스 내부 메서드는 1줄 공백으로 구분
- **연산자 공백**: 이항 연산자 양쪽에 공백 추가 (`a + b`, `x == y`)
- **불필요한 공백 금지**: 
  - 괄호 내부 양끝: `(a)` (O), `( a )` (X)
  - 쉼표, 세미콜론, 콜론 앞: `a, b` (O), `a , b` (X)

#### 2.1.4. 괄호 및 구분자
- **Trailing comma**: 다중 라인 구문에서 마지막 요소 뒤에 쉼표를 추가하여 버전 관리 시 변경사항을 명확히 하고 코드 일관성을 유지합니다.
- **괄호 사용**: 불필요한 괄호는 피하되, 가독성 향상을 위해서는 적극 활용합니다.

#### 2.1.5. 문자열 처리
- **인용부호**: 이중 인용부호(`"`) 우선 사용 (Ruff 기본 설정)
- **f-string 필수**: 문자열 포매팅 시 f-string을 반드시 사용하여 가독성과 성능을 향상시킵니다. `.format()` 메서드나 `%` 포매팅은 지양합니다.

### 2.2. 포맷팅 도구: Ruff
- **통합 도구**: Ruff를 통해 린팅, 포맷팅, 임포트 정렬을 일괄 처리
- **자동 포맷팅**: `ruff format` 명령으로 일관된 코드 스타일 유지
- **실시간 적용**: IDE 플러그인을 통한 저장 시 자동 포맷팅 권장

### 2.3. 임포트 정렬 (isort 호환)
- **그룹 순서**: 
  1. 표준 라이브러리 (예: `os`, `sys`, `json`)
  2. 서드파티 라이브러리 (예: `requests`, `google-cloud-*`)
  3. 로컬 애플리케이션/라이브러리 (예: `spaceone.inventory.*`)
- **그룹 간 공백**: 각 그룹 사이에 빈 줄 추가
- **알파벳 순서**: 각 그룹 내에서 알파벳 순으로 정렬

---

## 3. 복잡도 관리 (Complexity Management)

### 3.1. 크기 제한 (권고 기준)

코드의 가독성과 유지보수성을 위해 다음 기준을 **강력히 권고**합니다. 이는 하드 금지 규칙이 아닌 코드 품질 향상을 위한 지침입니다.

#### 3.1.1. 함수/메서드 길이
- **권고 기준**: ≤ 20줄
- **상한 기준**: ≤ 40줄
- **초과 시 대응 방안**:
  - 기능 단위로 함수 분리
  - Early return 패턴 활용
  - 헬퍼 함수 추출
  - 복잡한 조건문을 별도 함수로 분리

#### 3.1.2. 클래스 길이
- **권고 기준**: ≤ 200줄
- **상한 기준**: ≤ 300줄
- **초과 시 대응 방안**:
  - 단일 책임 원칙(SRP)에 따라 역할별 클래스 분리
  - Mixin 클래스 활용으로 기능 분산
  - 상속 구조 재검토

#### 3.1.3. 파일 길이
- **권고 기준**: ≤ 400줄
- **상한 기준**: ≤ 600줄
- **초과 시 대응 방안**:
  - 도메인별, 기술별 모듈 분리
  - 내부 서브모듈화 (`_internal.py` 등)
  - 관련 클래스들을 별도 파일로 이동

### 3.2. 복잡도 제한

#### 3.2.1. Cyclomatic Complexity (맥케이브 복잡도)
- **기준**: 함수당 ≤ 10
- **측정 방법**: if, while, for, except 등 분기점 개수
- **초과 시 대응**: 조건문 단순화, 함수 분리, 룩업 테이블 활용

#### 3.2.2. Cognitive Complexity (인지 복잡도)
- **기준**: 함수당 ≤ 15
- **특징**: 중첩 구조에 가중치를 부여한 복잡도 측정
- **초과 시 대응**: 중첩 구조 감소, Guard clause 패턴 활용

#### 3.2.3. 중첩 깊이
- **기준**: 최대 3단계
- **초과 시 대응**: 중첩이 3단계를 초과할 경우, 가독성을 위해 로직의 일부를 별도 함수로 추출하거나 Guard Clause 패턴을 활용하여 중첩 구조를 단순화합니다.

#### 3.2.4. 함수 파라미터 수
- **권고 기준**: ≤ 5개
- **초과 시 대응 방안**:
  - 관련 파라미터를 dataclass나 NamedTuple로 그룹화
  - 설정 객체 패턴 활용
  - 키워드 전용 인자 사용

### 3.3. 복잡도 관리 전략

#### 3.3.1. Guard Clause 패턴
함수의 시작 부분에서 유효하지 않은 조건을 먼저 검사하고 즉시 반환하는 패턴을 활용합니다. 이는 불필요한 `else` 블록과 깊은 들여쓰기를 줄여 코드의 가독성을 높입니다.

#### 3.3.2. 전략 패턴 활용
여러 조건에 따라 다른 로직이 실행되어야 할 때, 긴 `if/elif/else` 문 대신 딕셔너리나 클래스 매핑을 활용하여 확장성을 높이고 복잡도를 줄입니다.

---

## 4. 데이터 타입 및 연산 규칙 (Data Type & Operation Rules)

### 4.1. 비용 계산 시 `Decimal` 타입 사용

모든 비용(cost) 및 환율(exchange rate) 등 정확한 소수점 연산이 필요한 모든 데이터 처리에는 부동소수점(`float`) 타입으로 인한 오차를 원천적으로 방지하기 위해 `Decimal` 타입을 **반드시** 사용해야 합니다.

#### 사용 원칙:
- **문자열 생성**: `Decimal` 객체 생성 시 `Decimal("0.1")`과 같이 문자열을 사용하여 정확한 값을 보장합니다.
- **타입 일관성**: `Decimal` 타입끼리만 연산하여 정확성을 유지합니다.
- **부동소수점 혼용 금지**: `float`나 `int`와의 직접 연산을 피하고, 필요시 문자열로 변환 후 `Decimal`로 생성합니다.

---

## 5. Import 규칙 (Import Rules)

### 5.1. 기본 원칙
- **계층 분리**: 같은 계층(예: service, manager, model)의 패키지를 서로 임포트하지 않습니다.
- **순환 참조 방지**: `Service` → `Manager` → `Connector` 순서의 의존성을 가지므로, 하위 계층에서 상위 계층을 직접 Import하지 않습니다.
- **임포트 최적화**: 사용하지 않는 임포트를 제거합니다.
- **직접 임포트**: `__init__.py`에서 임포트하는 대신 필요한 곳에서 직접 임포트하는 것을 선호합니다.

### 5.2. 개발 환경 및 의존성 관리
- **`spaceone` 패키지 Mocking**: 로컬에서 `spaceone` 관련 패키지 Import 오류 발생 시, 테스트나 개발에 필요한 부분만 Mock 객체로 처리하여 호환성을 유지합니다.

### 5.3. 와일드카드 Import 금지
- **`from ... import *` 사용 금지**: 와일드카드 임포트는 네임스페이스를 오염시키고 코드 가독성을 해치므로 절대 사용하지 않습니다.

---

## 6. 주석 및 문서화 (Comments & Documentation)

### 6.1. Docstrings (Google 스타일)
- **필수 대상**: 모든 공개 함수, 메서드, 클래스에는 Google 스타일 Docstring 작성
- **타입 힌트 필수**: API 함수는 반드시 타입 힌트와 함께 작성
- **한국어 작성**: 이해를 돕기 위해 한국어로 작성

```python
def calculate_cost(usage_data: dict, rate: float = 0.1) -> float:
    """비용을 계산합니다.

    Args:
        usage_data: 사용량 데이터 딕셔너리.
        rate: 요금률 (기본값: 0.1).

    Returns:
        계산된 총 비용.

    Raises:
        ValueError: usage_data가 비어있을 경우.
    """
    if not usage_data:
        raise ValueError("Usage data cannot be empty.")
    # ...
```

### 6.2. 코드 내 주석 원칙
- **의도 설명**: 코드가 무엇을 하는지가 아닌, 왜 그렇게 구현했는지를 설명합니다.
- **비즈니스 로직 배경**: 특정 구현 방식을 선택한 이유나 제약사항을 명시합니다.
- **불필요한 주석 지양**: 코드 자체로 충분히 이해 가능한 내용은 주석을 작성하지 않습니다.
- **한국어 사용**: 복잡한 로직이나 특정 결정의 배경을 설명할 때 한국어로 작성합니다.
- **TODO 주석**: `# TODO: ` 형식으로 향후 처리할 작업을 명시합니다.

### 6.3. 프로젝트 문서화
- **`README.md`**: 각 디렉토리의 목적과 주요 기능을 설명 (국문 작성)
- **API 문서**: 모든 공개 API는 사용 예시와 함께 문서화
- **아키텍처 문서**: 시스템 구조와 컴포넌트 간 관계 설명

### 6.4. PRD (제품 요구사항 정의서) 작성
- **PRD 작성 가이드 준수**: 모든 백엔드 기능의 PRD는 반드시 `@/docs/ko/development/prd_generation_guide.md` 문서에 정의된 가이드라인을 따라야 합니다.
- **핵심 원칙**:
    - 기능 복잡도 분류, 백엔드 체크리스트, AI 요청 템플릿 등 가이드의 모든 절차를 따릅니다.
    - 구현 코드가 아닌 개념적 명세, 요구사항, 플로우 중심으로 작성합니다.

---

## 7. 에러 처리 (Error Handling)

### 7.1. 예외 처리
- **구체적인 예외 명시**: `except Exception:` 보다 `except ValueError:` 와 같이 구체적인 예외를 잡습니다.
- **사용자에게 명확한 메시지 제공**: 에러 메시지는 문제 해결에 도움이 되도록 명확하고 간결하게 작성합니다.
- **불필요한 변수 제거**: `except` 블록에서 예외 객체를 사용하지 않는다면 변수를 선언하지 않습니다.

### 7.2. 예외 다시 발생 (Re-raising)
- **`raise from`**: 원래의 예외(cause)를 포함하여 디버깅을 용이하게 합니다.

---

## 8. 타입 안전성 (Type Safety)

### 8.1. 타입 힌트 사용 원칙
- **타입 힌트 필수**: 모든 공개 함수, 메서드는 매개변수와 반환 타입에 타입 힌트 작성
- **정확한 타입 명시**: `Any` 타입 사용을 최대한 지양하고 구체적인 타입 명시
- **복합 타입**: `Union`, `Optional`, `Dict`, `List` 등을 적절히 활용

```python
from typing import Dict, List, Optional, Union
from decimal import Decimal

def process_resources(
    resources: List[Dict[str, Union[str, int]]],
    cost_multiplier: Optional[Decimal] = None,
) -> Dict[str, Decimal]:
    """리소스 목록을 처리하고 비용을 계산합니다."""
    # 구현...
```

### 8.2. 정적 타입 검사
- **mypy 활용**: 타입 검사 도구를 통한 컴파일 타임 오류 검출
- **CI 통합**: 지속적 통합 파이프라인에서 타입 검사 자동화

### 8.3. 타입 안전 패턴
- **dataclass 활용**: 구조화된 데이터를 위한 타입 안전한 데이터 클래스 사용
- **Enum 사용**: 상수 값들을 타입 안전하게 관리
- **Protocol 활용**: 덕 타이핑 대신 명시적 인터페이스 정의

```python
from dataclasses import dataclass
from enum import Enum
from typing import Protocol

class ResourceType(Enum):
    COMPUTE = "compute"
    STORAGE = "storage"
    NETWORK = "network"

@dataclass
class Resource:
    name: str
    type: ResourceType
    cost: Decimal

class ResourceProcessor(Protocol):
    def process(self, resource: Resource) -> Dict[str, str]:
        ...
```

---

## 9. 의존성 관리 (Dependency Management)

### 9.1. 패키지 관리 도구
- **pyproject.toml 우선**: 현대적 표준인 `pyproject.toml`을 사용하여 의존성 관리
- **requirements.txt 호환**: 레거시 시스템 지원을 위해 필요시 `requirements.txt` 병행 유지
- **가상환경 필수**: `venv`를 사용한 격리된 개발 환경 구성

### 9.2. 버전 관리 전략
- **Semantic Versioning**: 의존성 버전을 semver 형식으로 관리
- **최소/최대 버전 지정**: 호환성 범위를 명확히 지정
  ```toml
  dependencies = [
      "requests>=2.25.0,<3.0.0",
      "google-cloud-storage>=2.0.0,<3.0.0",
      "spaceone-core>=1.8.0",
  ]
  ```

### 9.3. 보안 및 라이선스 관리
- **의존성 감사**: 정기적인 보안 취약점 스캔 수행
- **라이선스 호환성**: 프로젝트 라이선스와 호환되는 의존성만 사용
- **업데이트 정책**: 보안 패치는 즉시 적용, 메이저 업데이트는 테스트 후 적용

### 9.4. 프로젝트 설정 (`pyproject.toml`)
```toml
[project]
name = "plugin-google-cloud-inventory-collector"
version = "1.0.0"
description = "Google Cloud inventory collector plugin for SpaceONE"
authors = [
    {name = "SpaceONE Team", email = "support@spaceone.dev"}
]
license = {text = "Apache License 2.0"}
readme = "README.md"
requires-python = ">=3.8"
dependencies = [
    "spaceone-core>=2.0.0",
    "spaceone-inventory>=2.0.0",
    "schematics>=2.1.0",
    "google-cloud-dataproc>=5.0.0",
    "google-cloud-compute>=1.15.0",
    "google-cloud-storage>=2.10.0",
    "google-cloud-monitoring>=2.15.0",
    "google-cloud-logging>=3.8.0",
    "google-auth>=2.23.0",
    "googleapiclient>=2.100.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-cov>=4.0.0",
    "pytest-asyncio>=0.21.0",
    "ruff>=0.1.6",
    "mypy>=1.6.0",
]

[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[tool.ruff]
line-length = 88
target-version = "py38"

[tool.ruff.lint]
select = ["E", "F", "I", "N", "W", "B", "C4", "UP", "C90"]
ignore = ["E501"]

[tool.ruff.lint.mccabe]
max-complexity = 10

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"

[tool.pytest.ini_options]
norecursedirs = "test/disabled"
testpaths = ["test"]
python_files = ["test_*.py"]
addopts = "--cov=src --cov-report=html --cov-report=term-missing"

[tool.mypy]
python_version = "3.8"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
ignore_missing_imports = true
```

---

## 10. 테스트 (Testing)

### 10.1. 테스트 작성 원칙
- **테스트 필수**: 모든 새로운 기능과 버그 수정에는 테스트 코드를 함께 작성
- **독립성**: 테스트는 서로 의존하지 않고 독립적으로 실행 가능
- **테스트 주도 개발(TDD)**: 가능한 경우 테스트를 먼저 작성하고 구현
- **코드 커버리지**: 핵심 로직은 높은 커버리지 유지 (80% 이상 권장)

### 10.2. 테스트 구조 (Given-When-Then)
```python
def test_calculate_cost_with_valid_data():
    # Given: 테스트 준비
    usage_data = {"cpu": 100, "memory": 512}
    rate = Decimal("0.1")
    
    # When: 테스트 실행
    result = calculate_cost(usage_data, rate)
    
    # Then: 결과 검증
    expected = Decimal("61.2")  # 100 * 0.1 + 512 * 0.1
    assert result == expected
```

### 10.3. Mock 활용
- **외부 의존성 격리**: `unittest.mock`을 사용하여 외부 서비스나 의존성 격리
- **테스트 안정성**: 외부 API 호출, 파일 I/O 등을 Mock으로 대체
- **예측 가능한 테스트**: 시간, 랜덤 값 등 비결정적 요소 제어

### 10.4. SpaceONE 프로젝트 특화 테스트 전략
- **gRPC API 테스트 지양**: `grpcurl`을 이용한 직접적인 API 테스트는 환경 구성의 복잡성으로 인해 권장하지 않음
- **핵심 로직 테스트**: `Manager`나 `Connector` 클래스를 직접 임포트하여 단위/통합 테스트 작성
- **Mock 기반 개발**: `spaceone` 패키지 의존성을 Mock으로 처리하여 로컬 개발 환경에서 테스트 실행

### 10.5. 테스트 실행 및 커버리지
```bash
# 기본 테스트 실행
pytest

# 커버리지와 함께 테스트 실행
pytest --cov=src --cov-report=html

# 특정 모듈만 테스트
pytest test/test_dataproc.py -v
```

---

## 11. 코드 품질 보증 (Code Quality Assurance)

모든 소스 코드 추가 및 수정 시, 아래의 절차를 반드시 수행하여 코드의 안정성과 품질을 보장합니다.

### 11.1. 개발 원칙
- **테스트 주도 개발 (TDD)**: 기능 구현 전, 실패하는 테스트 케이스를 먼저 작성하고 이를 통과시키는 코드를 개발하는 것을 원칙으로 합니다.
- **코드 커버리지**: 모든 코드 변경 사항은 충분한 테스트 코드로 뒷받침되어야 합니다. `pytest --cov`를 통해 커버리지를 측정하고, 핵심 로직은 높은 커버리지를 유지해야 합니다.

### 11.2. 필수 검증 절차
소스 코드 변경 후에는 반드시 다음 절차를 순서대로 진행하여 문제를 해결해야 합니다.

#### 11.2.1. 린터 및 포맷팅 검사
- **Ruff 통합 검사**: 코드 스타일, 포맷팅, 임포트 정렬을 일괄 처리
- **CI vs 로컬**: CI 환경에서는 `--check` 플래그로 문제만 확인, 로컬에서는 자동 수정 적용

```bash
# 가상환경 활성화
source venv/bin/activate

# (CI) 린트 및 포맷 검사
ruff check src/
ruff format src/ --check

# (Local) 린트 자동 수정 및 포맷팅 적용
ruff check src/ --fix
ruff format src/

# 타입 검사 (선택사항)
mypy src/
```

#### 11.2.2. 테스트 및 커버리지 측정
```bash
# 테스트 실행 및 커버리지 측정 (결과는 터미널에 출력)
pytest --cov=src

# 테스트 실행 및 커버리지 리포트(html) 생성
pytest --cov=src --cov-report=html

# 특정 모듈만 테스트
pytest test/test_specific_module.py -v
```

**테스트 결과 처리 원칙**:
- **`INTERNAL ERROR` 해결 최우선**: 테스트 코드 자체의 구조적 결함을 의미하므로 즉시 해결
- **`FAILED` 테스트 해결 필수**: 모든 테스트가 `PASSED` 상태여야 커밋/PR 가능
- **커버리지 확인**: `htmlcov/index.html`에서 커버리지 리포트 검토

#### 11.2.3. 정적 분석 및 보안 검사
```bash
# 보안 취약점 스캔 (선택사항)
bandit -r src/

# 복잡도 검사 (Ruff에 포함)
ruff check src/ --select C90
```

#### 11.2.4. 성능 테스트
- 데이터 처리 로직 변경 시 성능 테스트 수행
- 대용량 샘플 데이터로 실행 시간 및 메모리 사용량 측정

### 11.3. 자동화된 검증
- **IDE 연동**: 실시간 린트 및 타입 체크 기능 활성화
- **pre-commit hooks**: 커밋 전 자동 검증 설정
- **CI/CD 파이프라인**: PR 생성 시 모든 검증 절차 자동 수행

### 11.4. 품질 메트릭 목표
- **코드 커버리지**: 핵심 로직 100%
- **Cyclomatic Complexity**: 함수당 10 이하
- **테스트 성공률**: 100% (FAILED 테스트 허용 안 함)
- **린트 오류**: 0개 (모든 Ruff 규칙 통과)

---

## 12. 규칙 자동 검증

### 12.1. Ruff 기반 자동 검증

프로젝트의 주요 코딩 규칙은 `Ruff`를 통해 자동으로 검증됩니다. `grep`과 같은 수동 스크립트 대신 `ruff check src/` 명령을 실행하여 다음 규칙들이 준수되는지 확인합니다.

#### 12.1.1. 이름 규칙 (Naming Conventions)
- `N801`: 클래스명은 `PascalCase` (CapWords)여야 합니다.
- `N802`: 함수 및 메서드명은 `snake_case`여야 합니다.
- `N803`: 인수 이름은 `snake_case`여야 합니다.
- `N806`: 변수 이름은 `snake_case`여야 합니다.

#### 12.1.2. Import 규칙 (Import Rules)
- `I001`: 임포트가 정렬되지 않았습니다 (`ruff check --fix`로 자동 해결).
- `F401`: 사용하지 않는 임포트가 있습니다 (`ruff check --fix`로 자동 해결).

#### 12.1.3. 에러 처리 (Error Handling)
- `B014`: `except` 블록에서 사용하지 않는 예외 변수(예: `as e`)가 있습니다.
- `B904`: `raise` 문에서 `from` 없이 예외를 다시 발생시킵니다. (명시적 예외 체이닝 권장)

#### 12.1.4. 복잡도 및 품질 규칙
- `C90`: Cyclomatic complexity가 10을 초과합니다.
- `E501`: 라인 길이가 `line-length` 설정을 초과합니다. (`ruff format`으로 자동 해결)
- `F841`: 할당되었지만 사용되지 않은 지역 변수가 있습니다.

#### 12.1.5. 현대적 Python 코드 규칙
- `UP001`: f-string을 사용하여 `.format()` 호출을 대체하세요.
- `UP003`: `typing.List` 대신 `list`를 사용하세요 (Python 3.9+).
- `UP006`: `typing.Dict` 대신 `dict`를 사용하세요 (Python 3.9+).

### 12.2. 검증 명령어

```bash
# 모든 규칙 검사
ruff check src/

# 자동 수정 가능한 문제 해결
ruff check src/ --fix

# 포맷팅 적용
ruff format src/

# 특정 규칙만 검사
ruff check src/ --select N,I,F

# 복잡도만 검사
ruff check src/ --select C90
```

### 12.3. 참고 링크 및 리소스

#### 공식 문서
- [PEP8 (Style Guide for Python Code)](https://peps.python.org/pep-0008/)
- [PEP257 (Docstring Conventions)](https://peps.python.org/pep-0257/)
- [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html)

#### 도구별 문서
- [Ruff Rules 문서](https://docs.astral.sh/ruff/rules/)
- [pytest 공식 문서](https://docs.pytest.org/en/stable/)
- [mypy 공식 문서](http://mypy-lang.org/)

#### 품질 관리 도구
- [isort](https://pycqa.github.io/isort/)
- [coverage.py](https://coverage.readthedocs.io/)
- [bandit](https://bandit.readthedocs.io/) (보안 검사)

---

## 13. 프로젝트 특화 규칙

### 13.1. SpaceONE 플러그인 개발 규칙
- **Service-Manager-Connector 아키텍처**: 계층 간 의존성 순서 준수
- **Mock 기반 로컬 개발**: `spaceone` 패키지 의존성을 Mock으로 처리
- **Google Cloud 리소스 처리**: 각 GCP 서비스별 전용 커넥터 및 매니저 구현

### 13.2. 보안 및 인증 규칙
- **민감정보 하드코딩 금지**: API 키, 시크릿 등은 환경변수나 설정 파일로 관리
- **Google Cloud 인증**: Service Account 키 파일을 통한 인증 방식 사용
- **권한 최소화**: 필요한 최소한의 IAM 권한만 부여

### 13.3. 성능 최적화 규칙
- **순차 처리**: 안정성과 메모리 효율성을 위해 순차적 처리 방식 채택
- **배치 처리**: 대량 데이터 처리 시 적절한 배치 크기 설정
- **캐싱 전략**: 반복적인 API 호출 최소화를 위한 적절한 캐싱
- **타임아웃 관리**: 각 API 호출별 적절한 타임아웃 설정으로 안정성 확보



### 13.4. 스키마 및 응답 처리 규칙 (v2.0)

#### 13.4.1. 상태 추적 로깅 시스템
- **로깅 메서드 사용**: 응답 생성 시 반드시 `BaseResponse.create_with_logging()` 또는 `ErrorResourceResponse.create_with_logging()` 메서드를 사용합니다.
- **상태 카운터 관리**: 수집 시작 시 `reset_state_counters()` 호출, 완료 시 `log_state_summary()` 호출로 수집 결과를 요약합니다.
- **자동 상태 추적**: SUCCESS, FAILURE, TIMEOUT, UNKNOWN 상태별로 자동 카운팅되어 수집 성과를 추적합니다.

#### 13.4.2. 로깅 최적화 원칙
- **SUCCESS 상태 무음 처리**: 정상 처리는 카운터만 증가, 로그 스팸 방지
- **FAILURE/TIMEOUT 자동 로깅**: 에러 및 타임아웃은 자동으로 적절한 로그 레벨로 기록
- **로그 레벨 일관성**: ERROR (FAILURE), WARNING (TIMEOUT), INFO (요약 정보)

#### 13.4.3. 순차 처리 안전성 규칙
- **예외 처리 격리**: 개별 매니저의 실패가 전체 수집 프로세스에 영향을 주지 않도록 예외 처리를 구현합니다.
- **API 클라이언트 재사용**: 동일한 API 클라이언트를 안전하게 재사용하여 리소스 효율성을 높입니다.
- **순차적 타임아웃 관리**: 각 서비스별 적절한 타임아웃을 설정하여 안정적인 순차 처리를 보장합니다.
- **메모리 효율성**: 순차 처리를 통해 메모리 사용량을 최소화하고 안정성을 확보합니다.
- **성능 모니터링**: 처리 시간, 오류율 등을 지속적으로 모니터링하여 순차 처리 성능을 최적화합니다.

---

이 규칙들은 `pyproject.toml`의 `[tool.ruff.lint].select`에 포함된 규칙들에 의해 활성화됩니다. 새로운 규칙이 추가되거나 변경될 때는 이 문서를 함께 업데이트하여 팀원들과 공유해야 합니다.
